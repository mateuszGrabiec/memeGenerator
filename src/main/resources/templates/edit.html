<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="en">
<head>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <script src="konva.min.js"></script>
    <meta charset="utf-8"/>
    <title>Make meme</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f0f0f0;
        }

        #buttons {
            position: absolute;
            top: 5px;
            left: 10px;
        }

        #buttons > input {
            padding: 10px;
            display: block;
            margin-top: 5px;
        }
        .not-active {
            cursor: default;
            text-decoration: none;
            color: white;
        }
        a:hover{
            cursor: default;
            text-decoration: none;
            color: white;
        }
    </style>
</head>

<body>
<button id="save" class="btn btn-danger">Save as image</button>
<button id="gohome" class="btn btn-success"><a class="not-active" href="/">Go to list</a></button><br>
<div id="container" ></div>
<!--<div id="buttons">-->
<!--</div>-->
<script th:inline="javascript">
    var width = window.innerWidth;
    var height = window.innerHeight;

    var imgHeight = /*[[${meme.getHeight()}]]*/ +0 ;
    var imgWidth = /*[[${meme.getWidth()}]]*/ + 0;

    console.log(width);
    console.log(height);

    var stage = new Konva.Stage({
        container: 'container',
        width: width,
        height: height
    });

    var layer = new Konva.Layer();
    stage.add(layer);

    //num of box here
    var numOfTextbox =/*[[${meme.getBoxCount()}]]*/ +0;

    console.log(numOfTextbox);

    for (var i = 0; i < numOfTextbox; i++) {
        var textNode = new Konva.Text({
            text: 'Some text here',
            x: 50,
            y: 80,
            fill: 'black',
            stroke: 'white',
            strokeWidth: 1.5,
            fontStyle: 'bold',
            fontSize: 20,
            draggable: true,
            name: 'text-area',
            width: 200
        });


        layer.add(textNode);
        layer.draw();
    }

    var shapes = stage.find('.text-area');
    shapes.forEach(shape => {

        var tr = new Konva.Transformer({
            node: shape,
            name: 'tr',
            enabledAnchors: ['middle-left', 'middle-right'],
            // set minimum width of text
            boundBoxFunc: function(oldBox, newBox) {
                newBox.width = Math.max(30, newBox.width);
                return newBox;
            }
        });



        shape.on('transform', function() {
            //reset scale, so only with is changing by transformer
            shape.setAttrs({
                width: shape.width() * shape.scaleX(),
                scaleX: 1
            });
        });

        layer.add(tr);


        shape.on('dblclick', () => {
            dbClicked()
        });
        function dbClicked(){


            // hide text node and transformer:
            shape.hide();
            tr.hide();
            layer.draw();

            // create textarea over canvas with absolute position
            // first we need to find position for textarea
            // how to find it?

            // at first lets find position of text node relative to the stage:
            var textPosition = shape.absolutePosition();

            // then lets find position of stage container on the page:
            var stageBox = stage.container().getBoundingClientRect();

            // so position of textarea will be the sum of positions above:
            var areaPosition = {
                x: stageBox.left + textPosition.x,
                y: stageBox.top + textPosition.y
            };

            // create textarea and style it
            var textarea = document.createElement('textarea');
            document.body.appendChild(textarea);

            // apply many styles to match text on canvas as close as possible
            // remember that text rendering on canvas and on the textarea can be different
            // and sometimes it is hard to make it 100% the same. But we will try...
            textarea.value = shape.text();
            textarea.style.position = 'absolute';
            textarea.style.top = areaPosition.y + 'px';
            textarea.style.left = areaPosition.x + 'px';
            textarea.style.width = shape.width() - shape.padding() * 2 + 'px';
            textarea.style.height =
                shape.height() - shape.padding() * 2 + 5 + 'px';
            textarea.style.fontSize = shape.fontSize() + 'px';
            textarea.style.border = 'none';
            textarea.style.padding = '0px';
            textarea.style.margin = '0px';
            textarea.style.overflow = 'hidden';
            textarea.style.background = 'none';
            textarea.style.outline = 'none';
            textarea.style.resize = 'none';
            textarea.style.lineHeight = shape.lineHeight();
            textarea.style.fontFamily = shape.fontFamily();
            textarea.style.transformOrigin = 'left top';
            textarea.style.textAlign = shape.align();
            textarea.style.color = shape.fill();
            rotation = shape.rotation();
            var transform = '';
            if (rotation) {
                transform += 'rotateZ(' + rotation + 'deg)';
            }

            var px = 0;
            // also we need to slightly move textarea on firefox
            // because it jumps a bit
            var isFirefox =
                navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
            if (isFirefox) {
                px += 2 + Math.round(shape.fontSize() / 20);
            }
            transform += 'translateY(-' + px + 'px)';

            textarea.style.transform = transform;

            // reset height
            textarea.style.height = 'auto';
            // after browsers resized it we can set actual value
            textarea.style.height = textarea.scrollHeight + 3 + 'px';

            textarea.focus();

            function removeTextarea() {
                textarea.parentNode.removeChild(textarea);
                window.removeEventListener('click', handleOutsideClick);
                shape.show();
                tr.show();
                tr.forceUpdate();
                layer.draw();
            }

            function setTextareaWidth(newWidth) {
                if (!newWidth) {
                    // set width for placeholder
                    newWidth = shape.placeholder.length * shape.fontSize();
                }
                // some extra fixes on different browsers
                var isSafari = /^((?!chrome|android).)*safari/i.test(
                    navigator.userAgent
                );
                var isFirefox =
                    navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
                if (isSafari || isFirefox) {
                    newWidth = Math.ceil(newWidth);
                }

                var isEdge =
                    document.documentMode || /Edge/.test(navigator.userAgent);
                if (isEdge) {
                    newWidth += 1;
                }
                textarea.style.width = newWidth + 'px';
            }

            textarea.addEventListener('keydown', function(e) {
                // hide on enter
                // but don't hide on shift + enter
                if (e.keyCode === 13 && !e.shiftKey) {
                    shape.text(textarea.value);
                    removeTextarea();
                }
                // on esc do not set value back to node
                if (e.keyCode === 27) {
                    removeTextarea();
                }
                if (e.keyCode === 13) {
                    //confirm changes
                    tr.hide();
                    layer.draw();
                }
            });

            textarea.addEventListener('keydown', function(e) {
                scale = shape.getAbsoluteScale().x;
                setTextareaWidth(shape.width() * scale);
                textarea.style.height = 'auto';
                textarea.style.height =
                    textarea.scrollHeight + shape.fontSize() + 'px';
            });

            function handleOutsideClick(e) {
                if (e.target !== textarea) {
                    shape.text(textarea.value);
                    removeTextarea();
                }
            }
            setTimeout(() => {
                window.addEventListener('click', handleOutsideClick);
                window.addEventListener('touched', handleOutsideClick);
            });
        }

        var timeout;
        var lastTap = 0;
        shape.on('touchend', ()=> {
            var currentTime = new Date().getTime();
            var tapLength = currentTime - lastTap;
            clearTimeout(timeout);
            if (tapLength < 500 && tapLength > 0) {
                dbClicked();
                event.preventDefault();
            } else {
                timeout = setTimeout(function() {
                    clearTimeout(timeout);
                }, 500);
            }
            lastTap = currentTime;
        });

    });


    //url here
    var url =/*[[${meme.getUrl()}]]*/ +'';

    console.log(url);

    Konva.Image.fromURL(url, function (tempNode) {
        tempNode.setAttrs({
            x: 0,
            y: 0,
            scaleX:0.7,
            scaleY: 0.7
        });
        if(imgHeight>height) {
            tempNode.setAttrs({scaleX: 0.5,
                    scaleY:0.5})
        }
        layer.add(tempNode);
        tempNode.setZIndex(0);
        layer.batchDraw();
    });

    //save img

    function download() {
        var name = Date.now().toString()+".png";
        if(imgHeight>height) {
            stage.setWidth(imgWidth * 0.5);
            stage.setHeight(imgHeight * 0.5);
        }else {
            stage.setWidth(imgWidth * 0.7);
            stage.setHeight(imgHeight * 0.7);
        }

        var tr = stage.find('.tr');
        tr.forEach(border => {
            border.hide();
        });

        alert("ok");

        var userAgent = navigator.userAgent || navigator.vendor || window.opera;
        if(/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream){
            var link = document.createElement('a');
            var url= stage.toDataURL({format: 'png', multiplier: 4});
            link.href=url.replace(/^data:image\/[^;]/, 'data:application/octet-stream');
            link.download =name;
            link.click();
        }else {

            var tr = stage.find('.tr');
            tr.forEach(border => {
                border.hide();
            });


            var name = Date.now().toString()+".png";
            if(imgHeight>height) {
                stage.setWidth(imgWidth * 0.5);
                stage.setHeight(imgHeight * 0.5);
            }else {
                stage.setWidth(imgWidth * 0.7);
                stage.setHeight(imgHeight * 0.7);
            }
            var link = document.createElement("a");
            link.href = stage.toDataURL({format: 'png', multiplier: 4});
            link.download =name;
            link.click();
            delete link;
        }
    }

    document.getElementById('save').addEventListener("click",download);
    document.getElementById('save').addEventListener("touchend",download);

</script>
</body>
</html>
